#include "php_file.h"



namespace google {
namespace protobuf {
namespace compiler {
namespace php {

namespace {

bool PhpCollectExtensions(const Message& message,
                       vector<const FieldDescriptor*>* extensions) {
  return true;
}

void PhpCollectExtensions(const FileDescriptorProto& file_proto,
                       const DescriptorPool& alternate_pool,
                       vector<const FieldDescriptor*>* extensions,
                       const string& file_data) {
}

}  // namespace

FileGenerator::FileGenerator(const FileDescriptor* file)
   : file_(file),
     classname_("Hoge")
   {
  //   java_package_(FileJavaPackage(file)),
  //   classname_(FileClassName(file)) {

}

FileGenerator::~FileGenerator() {}

bool FileGenerator::Validate(string* error) {
  return true;
}

void FileGenerator::Generate(io::Printer* printer) {
}

void FileGenerator::GenerateEmbeddedDescriptor(io::Printer* printer) {
}

template<typename GeneratorClass, typename DescriptorClass>
static void GenerateSibling(const string& package_dir,
                            const string& php_package,
                            const DescriptorClass* descriptor,
                            GeneratorContext* context,
                            vector<string>* file_list,
                            const string& name_suffix,
                            void (GeneratorClass::*pfn)(io::Printer* printer)) {


  string filename = package_dir + descriptor->name() + name_suffix + ".php";
  file_list->push_back(filename);

  scoped_ptr<io::ZeroCopyOutputStream> output(context->Open(filename));
  io::Printer printer(output.get(), '$');

  printer.Print(
    "// Generated by the protocol buffer compiler.  DO NOT EDIT!\n"
    "// source: $filename$\n"
    "\n",
    "filename", descriptor->file()->name());

  GeneratorClass generator(descriptor);
  (generator.*pfn)(&printer);
}

void FileGenerator::GenerateSiblings(const string& package_dir,
                                     GeneratorContext* context,
                                     vector<string>* file_list) {

//  if (file_->options().java_multiple_files()) {
    // for (int i = 0; i < file_->enum_type_count(); i++) {
    //   GenerateSibling<EnumGenerator>(package_dir, java_package_,
    //                                  file_->enum_type(i),
    //                                  context, file_list, "",
    //                                  &EnumGenerator::Generate);
    // }
    for (int i = 0; i < file_->message_type_count(); i++) {
      // GenerateSibling<MessageGenerator>(package_dir, java_package_,
      //                                   file_->message_type(i),
      //                                   context, file_list, "OrBuilder",
      //                                   &MessageGenerator::GenerateInterface);

      GenerateSibling<MessageGenerator>(package_dir, php_package_,
                                        file_->message_type(i),
                                        context, file_list, "",
                                        &MessageGenerator::Generate);
    }
    // if (HasGenericServices(file_)) {
    //   for (int i = 0; i < file_->service_count(); i++) {
    //     GenerateSibling<ServiceGenerator>(package_dir, java_package_,
    //                                       file_->service(i),
    //                                       context, file_list, "",
    //                                       &ServiceGenerator::Generate);
    //   }
    // }
//  }

}

bool FileGenerator::ShouldIncludeDependency(const FileDescriptor* descriptor) {
  return true;
}

}  // namespace java
}  // namespace compiler
}  // namespace protobuf
}  // namespace google
